$date
	Sat Jul  4 20:49:27 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 32 4 pc [31:0] $end
$var wire 1 5 multoreg $end
$var wire 1 ( memwrite $end
$var wire 1 6 memtoreg $end
$var wire 1 7 lui $end
$var wire 1 8 lohi $end
$var wire 1 9 jr $end
$var wire 1 : jal $end
$var wire 1 ; domul $end
$var wire 1 < dojump $end
$var wire 1 = dobranch $end
$var wire 5 > destreg [4:0] $end
$var wire 1 ? alusrcbimm $end
$var wire 32 @ aluout [31:0] $end
$var wire 3 A alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 B instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 C op [5:0] $end
$var wire 6 D funct [5:0] $end
$var reg 3 E alucontrol [2:0] $end
$var reg 1 ? alusrcbimm $end
$var reg 5 F destreg [4:0] $end
$var reg 1 = dobranch $end
$var reg 1 < dojump $end
$var reg 1 ; domul $end
$var reg 1 : jal $end
$var reg 1 9 jr $end
$var reg 1 8 lohi $end
$var reg 1 7 lui $end
$var reg 1 6 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 5 multoreg $end
$var reg 1 3 regwrite $end
$upscope $end
$scope module dp $end
$var wire 3 G alucontrol [2:0] $end
$var wire 1 ? alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 H destreg [4:0] $end
$var wire 1 = dobranch $end
$var wire 1 ; domul $end
$var wire 32 I hi [31:0] $end
$var wire 32 J instr [31:0] $end
$var wire 1 : jal $end
$var wire 1 9 jr $end
$var wire 1 < jump $end
$var wire 32 K lo [31:0] $end
$var wire 1 8 lohi $end
$var wire 1 7 lui $end
$var wire 1 6 memtoreg $end
$var wire 1 5 multoreg $end
$var wire 32 L readdata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 1 " reset $end
$var wire 32 M writedata [31:0] $end
$var wire 1 1 zero $end
$var wire 32 N srcbimm [31:0] $end
$var wire 32 O srcb [31:0] $end
$var wire 32 P srca [31:0] $end
$var wire 32 Q signimm [31:0] $end
$var wire 32 R result [31:0] $end
$var wire 32 S pc [31:0] $end
$var wire 64 T mmout [63:0] $end
$var wire 32 U luiout [31:0] $end
$var wire 32 V aluout [31:0] $end
$scope module alu $end
$var wire 3 W alucontrol [2:0] $end
$var wire 32 X b [31:0] $end
$var wire 32 Y result [31:0] $end
$var wire 1 1 zero $end
$var wire 32 Z a [31:0] $end
$var reg 32 [ resreg [31:0] $end
$var reg 32 \ w1 [31:0] $end
$var reg 1 ] w2 $end
$var reg 1 ^ z $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 _ ra1 [4:0] $end
$var wire 5 ` ra2 [4:0] $end
$var wire 5 a wa3 [4:0] $end
$var wire 32 b wd3 [31:0] $end
$var wire 1 3 we3 $end
$var wire 32 c rd2 [31:0] $end
$var wire 32 d rd1 [31:0] $end
$upscope $end
$scope module lu $end
$var wire 16 e i [15:0] $end
$var wire 32 f o [31:0] $end
$upscope $end
$scope module m $end
$var wire 32 g a [31:0] $end
$var wire 32 h b [31:0] $end
$var wire 64 i out [63:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ! clk $end
$var wire 1 = dobranch $end
$var wire 1 < dojump $end
$var wire 1 9 jr $end
$var wire 26 j jumptarget [25:0] $end
$var wire 32 k progcounter [31:0] $end
$var wire 32 l register [31:0] $end
$var wire 1 " reset $end
$var wire 32 m nextpc [31:0] $end
$var wire 32 n incpc [31:0] $end
$var wire 32 o branchpc [31:0] $end
$var wire 32 p branchoffset [31:0] $end
$var reg 32 q pc [31:0] $end
$scope module pcbranch $end
$var wire 32 r b [31:0] $end
$var wire 1 s cin $end
$var wire 32 t y [31:0] $end
$var wire 1 u cout $end
$var wire 32 v a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 w a [31:0] $end
$var wire 32 x b [31:0] $end
$var wire 1 y cin $end
$var wire 32 z y [31:0] $end
$var wire 1 { cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 | a [15:0] $end
$var wire 32 } y [31:0] $end
$upscope $end
$scope module specr $end
$var wire 1 ! clk $end
$var wire 32 ~ hi_r [31:0] $end
$var wire 32 !" lo_r [31:0] $end
$var wire 1 ; mul_we $end
$var wire 64 "" mulres [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 ""
bx !"
bx ~
b1111011 }
b1111011 |
0{
b10000000000000000000100 z
0y
b100 x
b10000000000000000000000 w
b10000000000000000000100 v
0u
b10000000000000111110000 t
0s
b111101100 r
b10000000000000000000000 q
b1111011 p
b10000000000000111110000 o
b10000000000000000000100 n
b10000000000000000000100 m
b0 l
b10000000000000000000000 k
b10000000001111011 j
b0 i
b1111011 h
b0 g
b11110110000000000000000 f
b1111011 e
b0 d
b11001010111111101011101010111110 c
b1111011 b
b1 a
b1 `
b0 _
0^
0]
b1111011 \
b1111011 [
b0 Z
b1111011 Y
b1111011 X
b101 W
b1111011 V
b11110110000000000000000 U
b0 T
b10000000000000000000000 S
b1111011 R
b1111011 Q
b0 P
b11001010111111101011101010111110 O
b1111011 N
b11001010111111101011101010111110 M
bx L
bx K
b100100000000010000000001111011 J
bx I
b1 H
b101 G
b1 F
b101 E
b111011 D
b1001 C
b100100000000010000000001111011 B
b101 A
b1111011 @
1?
b1 >
0=
0<
0;
0:
09
x8
07
06
05
b10000000000000000000000 4
13
b11001010111111101011101010111110 2
01
bx 0
b100100000000010000000001111011 /
b100100000000010000000001111011 .
b0 -
b11001010111111101011101010111110 ,
bx +
b11110 *
b1111011 )
0(
b100100000000010000000001111011 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
b1111011 $
b1111011 ,
b1111011 2
b1111011 M
b1111011 O
b1111011 c
1!
#5
0"
#6
0!
#8
b111001000 R
b111001000 b
b110010 *
b10000000000000000001000 m
b111001000 )
b111001000 @
b111001000 V
b111001000 Y
b111001000 [
b111001000 \
b11100100000 r
b111001000 N
b111001000 X
b111001000 h
b1110010000000000000000000 U
b1110010000000000000000000 f
b11001010111111101011101010111110 $
b11001010111111101011101010111110 ,
b11001010111111101011101010111110 2
b11001010111111101011101010111110 M
b11001010111111101011101010111110 O
b11001010111111101011101010111110 c
b10000000000011100101000 o
b10000000000011100101000 t
b10 >
b10 F
b10 H
b10 a
b1000 D
b100000000111001000 j
b111001000 Q
b111001000 p
b111001000 }
b111001000 |
b111001000 e
b10 `
b10000000000000000001000 n
b10000000000000000001000 v
b10000000000000000001000 z
b100100000000100000000111001000 '
b100100000000100000000111001000 .
b100100000000100000000111001000 /
b100100000000100000000111001000 B
b100100000000100000000111001000 J
b1 -
b10000000000000000000100 &
b10000000000000000000100 4
b10000000000000000000100 S
b10000000000000000000100 k
b10000000000000000000100 q
b10000000000000000000100 w
1!
#10
0!
#12
b10000000000000000001100 m
b1100100 r
b110010000000000000000 U
b110010000000000000000 f
b1101101100011000 T
b1101101100011000 i
b1101101100011000 ""
b1111011 P
b1111011 Z
b1111011 d
b1111011 g
b1111011 l
b10000000000000001110000 o
b10000000000000001110000 t
bx >
bx F
bx H
bx a
03
1;
b11 A
b11 E
b11 G
b11 W
0?
b0 C
b11001 D
b1000100000000000011001 j
b11001 Q
b11001 p
b11001 }
b11001 |
b11001 e
b1 _
b111001000 $
b111001000 ,
b111001000 2
b111001000 M
b111001000 O
b111001000 c
b10000000000000000001100 n
b10000000000000000001100 v
b10000000000000000001100 z
b1000100000000000011001 '
b1000100000000000011001 .
b1000100000000000011001 /
b1000100000000000011001 B
b1000100000000000011001 J
b10 -
b10000000000000000001000 &
b10000000000000000001000 4
b10000000000000000001000 S
b10000000000000000001000 k
b10000000000000000001000 q
b10000000000000000001000 w
1!
#14
0!
#16
b10000000000000000010000 m
b1101101100011000 R
b1101101100011000 b
b0 N
b0 X
b0 h
b110000001001000 r
b11000000100100000000000000000 U
b11000000100100000000000000000 f
b0 T
b0 i
b0 ""
b0 P
b0 Z
b0 d
b0 g
b0 l
b0 $
b0 ,
b0 2
b0 M
b0 O
b0 c
b10000000110000001011000 o
b10000000110000001011000 t
08
15
b11 >
b11 F
b11 H
b11 a
13
0;
b10010 D
b1100000010010 j
b1100000010010 Q
b1100000010010 p
b1100000010010 }
b1100000010010 |
b1100000010010 e
b0 _
b0 `
b10000000000000000010000 n
b10000000000000000010000 v
b10000000000000000010000 z
b1100000010010 '
b1100000010010 .
b1100000010010 /
b1100000010010 B
b1100000010010 J
b11 -
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 S
b10000000000000000001100 k
b10000000000000000001100 q
b10000000000000000001100 w
b0 I
b0 ~
b1101101100011000 K
b1101101100011000 !"
1!
#18
0!
#20
b0 R
b0 b
b10000000000000000010100 m
b1000000001000000 r
b100000000100000000000000000000 U
b100000000100000000000000000000 f
b10000001000000001010100 o
b10000001000000001010100 t
18
b100 >
b100 F
b100 H
b100 a
b10000 D
b10000000010000 j
b10000000010000 Q
b10000000010000 p
b10000000010000 }
b10000000010000 |
b10000000010000 e
b10000000000000000010100 n
b10000000000000000010100 v
b10000000000000000010100 z
b10000000010000 '
b10000000010000 .
b10000000010000 /
b10000000010000 B
b10000000010000 J
b100 -
b10000000000000000010000 &
b10000000000000000010000 4
b10000000000000000010000 S
b10000000000000000010000 k
b10000000000000000010000 q
b10000000000000000010000 w
1!
#22
0!
#24
bx R
bx b
bx m
xu
bx N
bx X
bx h
bx00 r
bx0000000000000000 U
bx0000000000000000 f
bx T
bx i
bx ""
bx P
bx Z
bx d
bx g
bx l
bx $
bx ,
bx 2
bx M
bx O
bx c
bx o
bx t
x8
05
x<
x6
x(
x=
x?
bx >
bx F
bx H
bx a
x3
bx C
bx D
bx j
bx Q
bx p
bx }
bx |
bx e
bx _
bx `
b10000000000000000011000 n
b10000000000000000011000 v
b10000000000000000011000 z
bx '
bx .
bx /
bx B
bx J
b101 -
b10000000000000000010100 &
b10000000000000000010100 4
b10000000000000000010100 S
b10000000000000000010100 k
b10000000000000000010100 q
b10000000000000000010100 w
1!
#26
0!
#28
bx n
bx v
bx z
x{
bx -
bx &
bx 4
bx S
bx k
bx q
bx w
1!
#29
b100000 #
