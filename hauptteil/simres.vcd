$date
	Tue Jun 30 23:26:21 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 32 4 pc [31:0] $end
$var wire 1 5 multoreg $end
$var wire 1 ( memwrite $end
$var wire 1 6 memtoreg $end
$var wire 1 7 lui $end
$var wire 1 8 lohi $end
$var wire 1 9 jal $end
$var wire 1 : domul $end
$var wire 1 ; dojump $end
$var wire 1 < dobranch $end
$var wire 5 = destreg [4:0] $end
$var wire 1 > alusrcbimm $end
$var wire 32 ? aluout [31:0] $end
$var wire 3 @ alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 A instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 B op [5:0] $end
$var wire 6 C funct [5:0] $end
$var reg 3 D alucontrol [2:0] $end
$var reg 1 > alusrcbimm $end
$var reg 5 E destreg [4:0] $end
$var reg 1 < dobranch $end
$var reg 1 ; dojump $end
$var reg 1 : domul $end
$var reg 1 9 jal $end
$var reg 1 8 lohi $end
$var reg 1 7 lui $end
$var reg 1 6 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 5 multoreg $end
$var reg 1 3 regwrite $end
$upscope $end
$scope module dp $end
$var wire 3 F alucontrol [2:0] $end
$var wire 1 > alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 G destreg [4:0] $end
$var wire 1 < dobranch $end
$var wire 1 : domul $end
$var wire 32 H hi [31:0] $end
$var wire 32 I instr [31:0] $end
$var wire 1 9 jal $end
$var wire 1 ; jump $end
$var wire 32 J lo [31:0] $end
$var wire 1 8 lohi $end
$var wire 1 7 lui $end
$var wire 1 6 memtoreg $end
$var wire 1 5 multoreg $end
$var wire 32 K readdata [31:0] $end
$var wire 1 3 regwrite $end
$var wire 1 " reset $end
$var wire 32 L writedata [31:0] $end
$var wire 1 1 zero $end
$var wire 32 M srcbimm [31:0] $end
$var wire 32 N srcb [31:0] $end
$var wire 32 O srca [31:0] $end
$var wire 32 P signimm [31:0] $end
$var wire 32 Q result [31:0] $end
$var wire 32 R pc [31:0] $end
$var wire 64 S mmout [63:0] $end
$var wire 32 T luiout [31:0] $end
$var wire 32 U aluout [31:0] $end
$scope module alu $end
$var wire 3 V alucontrol [2:0] $end
$var wire 32 W b [31:0] $end
$var wire 32 X result [31:0] $end
$var wire 1 1 zero $end
$var wire 32 Y a [31:0] $end
$var reg 32 Z resreg [31:0] $end
$var reg 32 [ w1 [31:0] $end
$var reg 1 \ w2 $end
$var reg 1 ] z $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 ^ ra1 [4:0] $end
$var wire 5 _ ra2 [4:0] $end
$var wire 5 ` wa3 [4:0] $end
$var wire 32 a wd3 [31:0] $end
$var wire 1 3 we3 $end
$var wire 32 b rd2 [31:0] $end
$var wire 32 c rd1 [31:0] $end
$upscope $end
$scope module lu $end
$var wire 16 d i [15:0] $end
$var wire 32 e o [31:0] $end
$upscope $end
$scope module m $end
$var wire 32 f a [31:0] $end
$var wire 32 g b [31:0] $end
$var wire 64 h out [63:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ! clk $end
$var wire 1 < dobranch $end
$var wire 1 ; dojump $end
$var wire 26 i jumptarget [25:0] $end
$var wire 32 j progcounter [31:0] $end
$var wire 32 k register [31:0] $end
$var wire 1 " reset $end
$var wire 32 l nextpc [31:0] $end
$var wire 32 m incpc [31:0] $end
$var wire 32 n branchpc [31:0] $end
$var wire 32 o branchoffset [31:0] $end
$var reg 32 p pc [31:0] $end
$scope module pcbranch $end
$var wire 32 q b [31:0] $end
$var wire 1 r cin $end
$var wire 32 s y [31:0] $end
$var wire 1 t cout $end
$var wire 32 u a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 v a [31:0] $end
$var wire 32 w b [31:0] $end
$var wire 1 x cin $end
$var wire 32 y y [31:0] $end
$var wire 1 z cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 { a [15:0] $end
$var wire 32 | y [31:0] $end
$upscope $end
$scope module specr $end
$var wire 1 ! clk $end
$var wire 32 } hi_r [31:0] $end
$var wire 32 ~ lo_r [31:0] $end
$var wire 1 : mul_we $end
$var wire 64 !" mulres [63:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 !"
bx ~
bx }
b11 |
b11 {
0z
b10000000000000000000100 y
0x
b100 w
b10000000000000000000000 v
b10000000000000000000100 u
0t
b10000000000000000010000 s
0r
b1100 q
b10000000000000000000000 p
b11 o
b10000000000000000010000 n
b10000000000000000000100 m
b10000000000000000001100 l
b0 k
b10000000000000000000000 j
b100000000000000000011 i
b0 h
b11001010111111101011101010111110 g
b0 f
b110000000000000000 e
b11 d
b0 c
b11001010111111101011101010111110 b
b10000000000000000000100 a
b11111 `
b10000 _
b0 ^
x]
x\
bx [
bx Z
b0 Y
bx X
b11001010111111101011101010111110 W
b11 V
bx U
b110000000000000000 T
b0 S
b10000000000000000000000 R
b10000000000000000000100 Q
b11 P
b0 O
b11001010111111101011101010111110 N
b11001010111111101011101010111110 M
b11001010111111101011101010111110 L
bx K
bx J
b1100000100000000000000000011 I
bx H
b11111 G
b11 F
b11111 E
b11 D
b11 C
b11 B
b1100000100000000000000000011 A
b11 @
bx ?
0>
b11111 =
0<
1;
0:
19
x8
07
06
05
b10000000000000000000000 4
13
b11001010111111101011101010111110 2
x1
bx 0
b1100000100000000000000000011 /
b1100000100000000000000000011 .
b0 -
b11001010111111101011101010111110 ,
bx +
bx *
bx )
0(
b1100000100000000000000000011 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
1!
#5
0"
#6
0!
#8
b11110 *
b10000000000000000010000 l
01
0]
b1111011 )
b1111011 ?
b1111011 U
b1111011 X
b1111011 Z
0\
b1111011 [
b1111011 M
b1111011 W
b1111011 g
b111101100 q
b11110110000000000000000 T
b11110110000000000000000 e
b10000000000000111111100 n
b10000000000000111111100 s
09
b101 @
b101 D
b101 F
b101 V
0;
1>
b101 =
b101 E
b101 G
b101 `
b1001 B
b111011 C
b1010000000001111011 i
b1111011 P
b1111011 o
b1111011 |
b1111011 {
b1111011 d
b101 _
b10000000000000000010000 m
b10000000000000000010000 u
b10000000000000000010000 y
b1111011 Q
b1111011 a
b100100000001010000000001111011 '
b100100000001010000000001111011 .
b100100000001010000000001111011 /
b100100000001010000000001111011 A
b100100000001010000000001111011 I
b11 -
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 R
b10000000000000000001100 j
b10000000000000000001100 p
b10000000000000000001100 v
1!
#10
0!
#12
b10000000000000000000100 l
b100000 q
b0 M
b0 W
b0 g
b10000000000000000000 T
b10000000000000000000 e
b0 S
b0 h
b0 !"
b10000000000000000000100 O
b10000000000000000000100 Y
b10000000000000000000100 c
b10000000000000000000100 f
b10000000000000000000100 k
b10000000000000000110100 n
b10000000000000000110100 s
b0 =
b0 E
b0 G
b0 `
03
b11 @
b11 D
b11 F
b11 V
0>
b0 B
b1000 C
b11111000000000000000001000 i
b1000 P
b1000 o
b1000 |
b1000 {
b1000 d
b11111 ^
b0 _
b0 $
b0 ,
b0 2
b0 L
b0 N
b0 b
b10000000000000000010100 m
b10000000000000000010100 u
b10000000000000000010100 y
b11111000000000000000001000 '
b11111000000000000000001000 .
b11111000000000000000001000 /
b11111000000000000000001000 A
b11111000000000000000001000 I
b100 -
b10000000000000000010000 &
b10000000000000000010000 4
b10000000000000000010000 R
b10000000000000000010000 j
b10000000000000000010000 p
b10000000000000000010000 v
1!
#14
0!
#16
b111001000 Q
b111001000 a
b110010 *
b0 l
b111001000 )
b111001000 ?
b111001000 U
b111001000 X
b111001000 Z
b111001000 [
b111001000 M
b111001000 W
b111001000 g
b11100100000 q
b1110010000000000000000000 T
b1110010000000000000000000 e
b0 O
b0 Y
b0 c
b0 f
b0 k
b11001010111111101011101010111110 $
b11001010111111101011101010111110 ,
b11001010111111101011101010111110 2
b11001010111111101011101010111110 L
b11001010111111101011101010111110 N
b11001010111111101011101010111110 b
b10000000000011100101000 n
b10000000000011100101000 s
b101 @
b101 D
b101 F
b101 V
1>
b110 =
b110 E
b110 G
b110 `
13
b1001 B
b1100000000111001000 i
b111001000 P
b111001000 o
b111001000 |
b111001000 {
b111001000 d
b0 ^
b110 _
b10000000000000000001000 m
b10000000000000000001000 u
b10000000000000000001000 y
b100100000001100000000111001000 '
b100100000001100000000111001000 .
b100100000001100000000111001000 /
b100100000001100000000111001000 A
b100100000001100000000111001000 I
b1 -
b10000000000000000000100 &
b10000000000000000000100 4
b10000000000000000000100 R
b10000000000000000000100 j
b10000000000000000000100 p
b10000000000000000000100 v
1!
#18
0!
#20
b10000000000000000001100 l
b100 Q
b100 a
b1100 q
b11001010111111101011101010111110 M
b11001010111111101011101010111110 W
b11001010111111101011101010111110 g
b110000000000000000 T
b110000000000000000 e
b10000 n
b10000 s
19
b11 @
b11 D
b11 F
b11 V
1;
0>
b11111 =
b11111 E
b11111 G
b11111 `
b11 B
b11 C
b100000000000000000011 i
b11 P
b11 o
b11 |
b11 {
b11 d
b10000 _
b11001010111111101011101010111110 $
b11001010111111101011101010111110 ,
b11001010111111101011101010111110 2
b11001010111111101011101010111110 L
b11001010111111101011101010111110 N
b11001010111111101011101010111110 b
b100 m
b100 u
b100 y
b1100000100000000000000000011 '
b1100000100000000000000000011 .
b1100000100000000000000000011 /
b1100000100000000000000000011 A
b1100000100000000000000000011 I
b0 -
b0 &
b0 4
b0 R
b0 j
b0 p
b0 v
1!
#22
0!
#24
b11110 *
b10000000000000000010000 l
b1111011 )
b1111011 ?
b1111011 U
b1111011 X
b1111011 Z
b1111011 [
b1111011 M
b1111011 W
b1111011 g
b111101100 q
b11110110000000000000000 T
b11110110000000000000000 e
b1111011 $
b1111011 ,
b1111011 2
b1111011 L
b1111011 N
b1111011 b
b10000000000000111111100 n
b10000000000000111111100 s
09
b101 @
b101 D
b101 F
b101 V
0;
1>
b101 =
b101 E
b101 G
b101 `
b1001 B
b111011 C
b1010000000001111011 i
b1111011 P
b1111011 o
b1111011 |
b1111011 {
b1111011 d
b101 _
b10000000000000000010000 m
b10000000000000000010000 u
b10000000000000000010000 y
b1111011 Q
b1111011 a
b100100000001010000000001111011 '
b100100000001010000000001111011 .
b100100000001010000000001111011 /
b100100000001010000000001111011 A
b100100000001010000000001111011 I
b11 -
b10000000000000000001100 &
b10000000000000000001100 4
b10000000000000000001100 R
b10000000000000000001100 j
b10000000000000000001100 p
b10000000000000000001100 v
1!
#25
b11111 #
